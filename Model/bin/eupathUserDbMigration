#!/usr/bin/perl

use Getopt::Long;
use strict;

my ($controlDir, $primaryModel, $projects, $removeGuestsCutoff, $questionsMappingFile, $organismsMappingFile, $stopAfterStep, $skipStepsString, $listSteps, $schema, $skipReplicationSteps, $cleanAppDbWdkCache, $cleanUserDbModelCache, $cleanExpandedSteps, $projectsWithMapping, $stepsSpecName, $validateSteps, $configFileTemplate);

&GetOptions('controlDir=s' => \$controlDir,
            'stepsSpecName=s' => \$stepsSpecName,
            'skipSteps=s' => \$skipStepsString,
            'skipReplicationSteps!' => \$skipReplicationSteps,
            'stopAfterStep=s' => \$stopAfterStep,
	    'listSteps!' => \$listSteps,
	    'validateSteps!' => \$validateSteps,

	    # step specific arguments
            'primaryModel=s' => \$primaryModel,
            'projects=s' => \$projects,
            'projectsWithMapping=s' => \$projectsWithMapping,
            'removeGuestsCutoff=s' => \$removeGuestsCutoff,
            'questionsMappingFile=s' => \$questionsMappingFile,
            'organismsMappingFile=s' => \$organismsMappingFile,
            'schema=s' => \$schema,
            'cleanAppDbWdkCache!' => \$cleanAppDbWdkCache,
            'cleanUserDbModelCache!' => \$cleanUserDbModelCache,
            'cleanExpandedSteps!' => \$cleanExpandedSteps,
            'configFileTemplate=s' => \$configFileTemplate,
           );


# columns:
#  -name
#  -command
#  -step only needed if replication context
#  -required command line arg values
#  -PROJECT_MACRO values list

my $REPLIC_STEP = 1;
my %stepsSpec;

$stepsSpec{middleOfRelease} =
  [
   ['buildConfigFiles', "eupathMultiSiteConfig '$projects $configFileTemplate'", !$REPLIC_STEP, $projects, $configFileTemplate ],
   ['wdkCacheModel', "wdkCacheModel -expand -model '$projects'", !$REPLIC_STEP, $projects ],
   ['mapOrganism', "eupathMapOrganism PROJECT_MACRO $organismsMappingFile" , !$REPLIC_STEP, $organismsMappingFile && $projectsWithMapping, $projectsWithMapping],
   ['mapQuestionName', "eupathMapQuestion PROJECT_MACRO $questionsMappingFile" , !$REPLIC_STEP, $questionsMappingFile && $projectsWithMapping, $projectsWithMapping],
   ['expandStep', "wdkExpandStep -model $primaryModel", !$REPLIC_STEP, $primaryModel],
   ['invalidStepReport',"wdkInvalidStepReport -model $primaryModel", !$REPLIC_STEP, $primaryModel],
  ];

$stepsSpec{release} =
  [
   ['removeGuests', "wdkRemoveGuests -model $primaryModel -cutoffDate $removeGuestsCutoff", !$REPLIC_STEP, $primaryModel && $removeGuestsCutoff],
   ['sleepAfterRemoveGuests', "sleep 1800", $REPLIC_STEP, 1 ], #wait for replication to catch up
   ['validateReplAfterGuests', "validateReplication -schema $schema -rowTolerance 20", $REPLIC_STEP, $schema],
   ['removeBroken', "wdkRemoveBroken -model $primaryModel", !$REPLIC_STEP, $primaryModel], # remove broken strategies
   ['sleepAfterRemoveBroken', "sleep 1800" , $REPLIC_STEP ], #wait for replication to catch up
   ['validateReplAfterBroken', "validateReplication -schema $schema -rowTolerance 20" , $REPLIC_STEP, $schema ],
   @{$stepsSpec{middleOfRelease}},
   ['validateSteps', "wdkValidateStep -model PROJECT_MACRO", !$REPLIC_STEP , $projects, $projects],
  ];

$stepsSpec{test} =
  [
   ['echo-1', "sleep 10; echo $stepsSpecName", !$REPLIC_STEP, $stepsSpecName],
   ['echo-2', "sleep 10; echo $primaryModel", $REPLIC_STEP, $primaryModel],
   ['echo-3', "sleep 10; echo PROJECT_MACRO", $REPLIC_STEP, 1, "PlasmoDB, ToxoDB"],
   ['ls','ls /home/pickle', !$REPLIC_STEP, 1],
  ];

usage() unless $stepsSpecName && ($controlDir || $listSteps || $validateSteps);

my $stepsSpec = $stepsSpec{$stepsSpecName};
die "Error: can't find steps spec with name '$stepsSpecName'\n" unless $stepsSpec;

my %unexpandedStepsSpec;
foreach my $stepSpec (@$stepsSpec) {
  die "Duplicate step name '$unexpandedStepsSpec{$stepSpec->[0]}'\n" if $unexpandedStepsSpec{$stepSpec->[0]};
  $unexpandedStepsSpec{$stepSpec->[0]} = 1;
}

my %skipSteps;
if ($skipStepsString) {
  my @skipSteps = split(/,\s*/, $skipStepsString);
  foreach my $stepName (@skipSteps) {
    die "Trying to skip step '$stepName' which does not exist\n" unless $unexpandedStepsSpec{$stepName};
    $skipSteps{$stepName} = 1;
  }
}


# expand steps with PROJECT_MACRO
# and validate that all included steps have their required args satisfied.
my @expandedSteps;
foreach my $stepSpec (@$stepsSpec) {
  my $step = {};
  ($step->{name}, $step->{cmd}, $step->{isReplic}, $step->{hasReqdArgs}, $step->{projectMacroValues}) = @$stepSpec;

  $step->{skip} = $skipSteps{$step->{name}} || $step->{isReplic} && $skipReplicationSteps;

  if ($step->{skip}) {
    push(@expandedSteps, $step);
    print STDERR "$step->{name}: SKIPPING\n" if $validateSteps;
    next;
  }

  die "Step '$step->{name}' can't be run because its command depends on cmd line arguments you didn't provide. Here is the command:\n$step->{cmd}\n" unless $step->{hasReqdArgs};
  die "Step '$step->{name}' includes a PROJECT_MACRO but no projects were included for it on the cmd line\n" if $step->{cmd} =~ /PROJECT_MACRO/ && !$step->{projectMacroValues};

  if ($step->{projectMacroValues}) {
    my @projectNames = split(/,\s*/, $step->{projectMacroValues});
    foreach my $projectName (@projectNames) {
      my $newStep = {};
      $newStep->{name} = "$step->{name}-$projectName";
      $newStep->{cmd} = $step->{cmd};
      $newStep->{cmd} =~ s/PROJECT_MACRO/$projectName/g;
      push(@expandedSteps, $newStep);
      if ($validateSteps) {
	print STDERR "$newStep->{name}:\t$newStep->{cmd}\n";
	if ($stopAfterStep eq $newStep->{name}) {
	  print STDERR "StopAfter='$newStep->{name}'.  Exiting";
	  last;
	}
      }
    }
  } else {
    push(@expandedSteps, $step);
    if ($validateSteps) {
      print STDERR "$step->{name}:\t$step->{cmd}\n";
      if ($stopAfterStep eq $step->{name}) {
	print STDERR "StopAfter='$step->{name}'.  Exiting";
	last;
      }
    }
  }
}

exit 0 if $validateSteps;

chdir $controlDir || die "Can't 'chdir $controlDir'\n";
my $cursor = 0;
while (1) {
  my $step = $expandedSteps[$cursor];
  my $stepName = $step->{name};
  if (-e "$stepName.failed") {
    &log("Step '$stepName' failed.  Can't proceed");
    exit 1;
  }
  if (-e "$stepName.done") {
    &log("Step '$stepName' done");
    if ($stopAfterStep eq $stepName) {
      &log("StopAfter='$stepName'.  Exiting");
      exit 0;
    }
    $cursor++;
    next;
  }
  if (-e "$stepName.running") {
    next;
  }
  if ($step->{skip}) {
    &log("Step '$stepName' skipped");
    $cursor++;
    next;
  }
  &log("Step '$stepName' running: '$step->{cmd}'");
  my $cmd = "echo '$step->{cmd}' | eupathUserDbMigrationStepWrapper $stepName &";
  system($cmd) && die "Failed running '$cmd'";
  sleep(1);
}
&log("Pipeline run complete");

sub log {
  my ($msg) = @_;
  my $t = localtime;
  print STDERR "$t\t$msg\n\n";
}


sub usage {

  my $stepsSpecNames = join(", ", keys(%stepsSpec));

die "

eupathUserDbMigration --stepsSpecName spec_name {--controlDir my_control_dir | --listSteps | --validateSteps } [--stopAfterStep step_name] [--skipSteps comma_delim_list_of_steps] [--skipReplicationSteps]

Additional step-specific arguments (all are optional, required only if used by a step that will run):

--primaryModel PlasmoDB  --projects \"EuPathDB, PlasmoDB\" --projectsWithMapping \"EuPathDB, PlasmoDB\" --removeGuestsCutoff \"2016/1/15\"  --questionsMappingFile mapping_file --organismsMappingFile mapping_file --schema userslogin5 --cleanAppDbWdkCache --cleanUserDbModelCache --cleanExpandedSteps

Where:
  stepsSpecName: the name of a list of steps to run.  Options are: $stepsSpecNames
  controlDir: the dir in which this program will write all its log files
  listSteps: list the steps in the provided stepsSpecName.  (Does not expand steps based on PROJECT_MACRO)
  validateSteps: don't run any commands.  Just validate the steps in the provided stepsSpecName (expanding PROJECT_MACRO), confirming that all required step-specific args are provided.
  stopAfterStep: the name of the step to stop after (Default: none)
  skipSteps: a comma delimited list of steps to skip (Default: none)
  skipReplicationSteps: skip the steps marked as useful only in a replication context

Mapping files
The mapping files describe  mappings for question names and parameter values.
MORE DETAILS HERE...

";

}
