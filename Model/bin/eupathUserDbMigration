#!/usr/bin/perl

use Getopt::Long;
use strict;

# FOR NOW... the pipelines used by eupathUserDbMigration are HARD CODED in this file!

# To edit a pipeline, see all comments labeled with EDIT_PIPELINE

# EDIT_PIPELINE
# To add a step to a pipeline:
#  1) figure out what command line args you want to pass to it's command.  You will pass these in from command line args to eupathUserDbMigration
#  2) for each of those:
#      - decide on a command line argument prompt for eupathUserDbMigration, eg --cleanExpandedSteps
#      - add that to the GetOptions declaration
#        - if it is a boolean argument, use the ! notation (see, eg, keepUserDBCache)
#        - if it is a string argument, use the =s notation (see projects)
#      - if it is a file argument add it to the list in the section below that validates that file/dir args are full paths
#  3) add it to a row in one of the 


# EDIT_PIPELINE - Step 1
# Declare arguments here that will be passed from the eupathUserDbMigration command line to the commands called in the pipeline
my @stepSpecificArgs =
(
 'primaryModel=s',
 'projects=s',
 'projectsWithMapping=s',
 'removeGuestsCutoff=s',
 'questionsMappingFile=s',
 'organismsMappingFile=s',
 'schema=s',
 'keepUserDBCache!',
 'skipParams!',
 'metaFileNameTemplate=s',
);

my @argv = @ARGV; # save before emptied by getoptions
my %args;
&GetOptions(\%args,
      'controlDir=s',
      'stepsSpecName=s',
      'skipSteps=s',
      'usingSandbox!',
      'stopAfterStep=s',
      'listSteps!',
      'validateSteps!',
      @stepSpecificArgs
);

# EDIT_PIPELINE - Step 2
# Validate that each file or dir argument is a full path
foreach my $fileArg ($args{controlDir}, $args{questionsMappingFile}, $args{organismsMappingFile}) {
  die "Error: this file or dir argument must be a full path" if $fileArg && substr($fileArg, 0, 1) ne '/';
}

# EDIT_PIPELINE - Step 3
# Convert boolean input arguments from 0/1 to values that can be passed to the command we run
$args{keepUserDBCache} = $args{keepUserDBCache} ? '-keepCache': ' ';
$args{skipParams} = $args{skipParams} ? '-skipParams': ' ';


# EDIT_PIPELINE - Step 4
# Declare the pipelines!

# The following are a set of "steps specs."  Each step spec is a list of steps in a named pipeline, eg, updateAndReportOnSteps.
# Each spec has a number of rows, with each row representing a step in that pipeline.
# Each row has standard columns:
#  -step name
#  -command to run, which can include embedded args from the eupathUserDbMigration command line, or other variables, as needed
#  -a flag indicating if this step is only needed in a replication context.  Must be 0 or 1.
#  -a list of required eupathUserDbMigration command line args (those referred to by the command).  (Use [] if none).
#  -PROJECT_MACRO values list.  If the command includes a PROJECT_MACRO, then expand this single command into multiple commands, where each is instantiated with a single project from this list.

my $REPLIC_STEP = 1;

my %stepsSpec;


###############################################################################################################
############  Main pipelines                                                                   ################
############    these are in the rough order they will be used in the typical release scenario ################
###############################################################################################################

$stepsSpec{configureProjects} =
  [
   ['buildConfigFiles', "eupathMultiSiteConfigure '$args{projects}' $args{metaFileNameTemplate}", !$REPLIC_STEP, ['projects', 'metaFileNameTemplate'] ]
  ];

# Used by DD team relatively early in the cycle, to validate the SQL in the wdk model.
$stepsSpec{cacheModel} =
  [
   ['wdkCacheModelCreate', "wdkCacheModel -create -model '$args{projects}'", !$REPLIC_STEP, ['projects'] ],
   ['wdkCacheModel', "wdkCacheModel $args{keepUserDBCache} -expand -model '$args{projects}' $args{skipParams}", !$REPLIC_STEP, ['projects', 'keepUserDBCache', 'skipParams'] ],
  ];

$stepsSpec{dropCacheModel} =
  [
   ['wdkCacheModelDrop', "wdkCacheModel $args{keepUserDBCache} -drop -model '$args{projects}'", !$REPLIC_STEP, ['projects'] ],
  ];

# Used by Infra team, to sanity check step invalidation.  Work with DD to get a reasonable set of mappings.
$stepsSpec{updateAndReportOnSteps} =
  [
   @{$stepsSpec{configureProjects}},
   @{$stepsSpec{cacheModel}},
   ['mapOrganism', "eupathMapOrganism PROJECT_MACRO $args{organismsMappingFile}" , !$REPLIC_STEP, ['organismsMappingFile', 'projectsWithMapping'], $args{projectsWithMapping}],
   ['validateReplOrganism', "eupathValidateReplication -primaryModel $args{primaryModel} -rowTolerance 20 -sleep 10", $REPLIC_STEP, ['primaryModel']],

   ['mapQuestionName', "eupathMapQuestion PROJECT_MACRO $args{questionsMappingFile}" , !$REPLIC_STEP, ['questionsMappingFile', 'projectsWithMapping'], $args{projectsWithMapping}],
   ['validateReplQuestion', "eupathValidateReplication -primaryModel $args{primaryModel} -rowTolerance 20 -sleep 10", $REPLIC_STEP, ['primaryModel']],

   ['expandStep', "wdkExpandStep -model $args{primaryModel}", !$REPLIC_STEP, ['primaryModel']],
   ['validateReplExpand', "eupathValidateReplication -primaryModel $args{primaryModel} -rowTolerance 20 -sleep 10", $REPLIC_STEP, ['primaryModel']],

   ['invalidStepReport',"wdkInvalidStepReport -model $args{primaryModel}", !$REPLIC_STEP, ['primaryModel']],
  ];

# Is not called as part of release.  Can be done anytime during the cycle. 
$stepsSpec{cleanup} =
  [
   @{$stepsSpec{configureProjects}},
   @{$stepsSpec{dropCacheModel}},
   @{$stepsSpec{cacheModel}},
   ['guestUserReport', "eupathGuestUserReport --primaryModel $args{primaryModel}", !$REPLIC_STEP, ['primaryModel']],
   ['removeGuests', "wdkRemoveGuests -model $args{primaryModel} -cutoffDate $args{removeGuestsCutoff}", !$REPLIC_STEP, ['primaryModel', 'removeGuestsCutoff']],
   ['validateReplGuests', "eupathValidateReplication -primaryModel $args{primaryModel} -rowTolerance 20 -sleep 10", $REPLIC_STEP, ['primaryModel']],
   ['removeBroken', "wdkRemoveBroken -model $args{primaryModel}", !$REPLIC_STEP, ['primaryModel']], # remove broken strategies
   ['validateReplBroken', "eupathValidateReplication -primaryModel $args{primaryModel} -rowTolerance 20 -sleep 10", $REPLIC_STEP, ['primaryModel']],
  ];

# Called at release.  Doesn't need cleanup, because cleanup is not needed at release time.  It can be done at any time.
$stepsSpec{release} =
  [
   @{$stepsSpec{dropCacheModel}},
   @{$stepsSpec{updateAndReportOnSteps}},
   ['validateSteps', "wdkValidateStep -model PROJECT_MACRO", !$REPLIC_STEP , ['projects'], $args{projects}],
   ['validateReplValSteps', "eupathValidateReplication -primaryModel $args{primaryModel} -rowTolerance 20 -sleep 10", $REPLIC_STEP, ['primaryModel']],

   ['fixBaskets', "wdkFixBasket -model '$args{projects}'", !$REPLIC_STEP, ['projects'] ],
   ['validateReplBasket', "eupathValidateReplication -primaryModel $args{primaryModel} -rowTolerance 20 -sleep 10", $REPLIC_STEP, ['primaryModel']],
  ];


#####################################################################################################################
##########   Special case pipelines
#####################################################################################################################

$stepsSpec{gus4} =
  [
   @{$stepsSpec{configureProjects}},
   ['gus4', "gus4StepTableMigration PROJECT_MACRO $args{questionsMappingFile}" , !$REPLIC_STEP, ['questionsMappingFile', 'projects'], $args{projects}],
   # Cannot put validation here since it checks the whole DB (is not project-specific)
   #['validateGus4', "eupathValidateUserDb --primaryModel PlasmoDB --sqlFile $ENV{PROJECT_HOME}/EuPathSiteCommon/Model/lib/sql/Gus4MigrationValidation.sql", !$REPLIC_STEP, ['primaryModel']]
  ];

$stepsSpec{gus4Ortho} =
  [
   @{$stepsSpec{configureProjects}},
   ['gus4', "eupathGus4StepTableMigration '$args{projects}' " , !$REPLIC_STEP, ['projects'] ],
  ];


######################################################################################################################
##########  Redundant individual pipelines, possibly used for convenience sometimes
######################################################################################################################

$stepsSpec{mappingQuestOrgs} =
  [
   @{$stepsSpec{configureProjects}},
   ['mapOrganism', "eupathMapOrganism PROJECT_MACRO $args{organismsMappingFile}" , !$REPLIC_STEP, ['organismsMappingFile', 'projectsWithMapping'], $args{projectsWithMapping}],
   ['mapQuestionName', "eupathMapQuestion PROJECT_MACRO $args{questionsMappingFile}" , !$REPLIC_STEP, ['questionsMappingFile', 'projectsWithMapping'], $args{projectsWithMapping}],
  ];

$stepsSpec{fixBaskets} =
  [
   @{$stepsSpec{configureProjects}},
   ['fixBaskets', "wdkFixBasket -model '$args{projects}'", !$REPLIC_STEP, ['projects'] ],
  ];

$stepsSpec{expand} =
  [
   @{$stepsSpec{configureProjects}},
   ['expandStep', "wdkExpandStep -model $args{primaryModel}", !$REPLIC_STEP, ['primaryModel']],
  ];

$stepsSpec{replValidation} =
  [
   @{$stepsSpec{configureProjects}},
   ['validateRepl', "eupathValidateReplication -primaryModel $args{primaryModel} -rowTolerance 20 -sleep 10", $REPLIC_STEP, ['primaryModel']],
  ];

$stepsSpec{validate} =
  [
   ['validateSteps', "wdkValidateStep -model PROJECT_MACRO", !$REPLIC_STEP , ['projects'], $args{projects}],
  ];

$stepsSpec{test} =
  [
   ['echo-1', "sleep 10; echo $args{stepsSpecName}", !$REPLIC_STEP, ['stepsSpecName']],
   ['echo-2', "sleep 10; echo $args{primaryModel}", $REPLIC_STEP, ['primaryModel']],
   ['echo-3', "sleep 10; echo PROJECT_MACRO", $REPLIC_STEP, [], "PlasmoDB, ToxoDB"],
   ['ls','ls /home/pickle', !$REPLIC_STEP, []],
  ];


usage() unless $args{stepsSpecName} && ($args{controlDir} || $args{listSteps} || $args{validateSteps});

print"\n";

# get desired steps spec, and validate that it has no duplicate step names
my $stepsSpec = $stepsSpec{$args{stepsSpecName}};
die "Error: can't find steps spec with name '$args{stepsSpecName}'\n" unless $stepsSpec;
my %unexpandedStepsSpec;
foreach my $stepSpec (@$stepsSpec) {
  die "Duplicate step name '$unexpandedStepsSpec{$stepSpec->[0]}'\n" if $unexpandedStepsSpec{$stepSpec->[0]};
  $unexpandedStepsSpec{$stepSpec->[0]} = 1;
}


# find steps to skip
my %skipSteps;
if ($args{skipSteps}) {
  my @skipSteps = split(/,\s*/, $args{skipSteps});
  foreach my $stepName (@skipSteps) {
    die "Trying to skip step '$stepName' which does not exist\n" unless $unexpandedStepsSpec{$stepName};
    $skipSteps{$stepName} = 1;
  }
}


# iterate through steps in spec
#   - construct step objects
#   - expand steps with PROJECT_MACRO
#   - validate that all included steps have their required args satisfied.
print STDERR "\nRunning in --validateSteps mode\n\n" if $args{validateSteps};
my @expandedSteps;
foreach my $stepSpec (@$stepsSpec) {
  my $step = {};
  ($step->{name}, $step->{cmd}, $step->{isReplic}, $step->{reqdArgsList}, $step->{projectMacroValues}) = @$stepSpec;
  $step->{hasReqdArgs} = 1;
  foreach my $argName (@{$step->{reqdArgsList}}) { $step->{hasReqdArgs} &= defined($args{$argName});}

  $step->{skip} = $skipSteps{$step->{name}} || $step->{isReplic} && $args{usingSandbox};

  # if skipping this step, remember that, and put out a message
  if ($step->{skip}) {
    push(@expandedSteps, $step);
    print STDERR "$step->{name}: SKIPPING\n" if $args{validateSteps};
    next;
  }

  # if not skipping this step, validate its input args
  die "Step '$step->{name}' can't be run because its command depends on cmd line arguments you didn't provide. The required args are: --" . join(", --", @{$step->{reqdArgsList}}) . "\n" unless $step->{hasReqdArgs};
  die "Step '$step->{name}' includes a PROJECT_MACRO but no projects were included for it on the cmd line\n" if $step->{cmd} =~ /PROJECT_MACRO/ && !$step->{projectMacroValues};

  # expand its PROJECT_MACRO, if it has one
  # and for each step, if only validating, put out the 
  my $stoppedAfter = 0;
  if ($step->{projectMacroValues}) {
    my @projectNames = split(/,\s*/, $step->{projectMacroValues});
    foreach my $projectName (@projectNames) {
      my $newStep = {};
      $newStep->{name} = "$step->{name}-$projectName";
      $newStep->{cmd} = $step->{cmd};
      $newStep->{cmd} =~ s/PROJECT_MACRO/$projectName/g;
      push(@expandedSteps, $newStep);
      last if ($stoppedAfter = &validatingAndStopAfter($newStep));
    }
  } else {
    push(@expandedSteps, $step);
    $stoppedAfter = &validatingAndStopAfter($step);
  }
  last if $stoppedAfter;
}

exit 0 if $args{validateSteps};

chdir $args{controlDir} || die "Can't 'chdir $args{controlDir}'\n";
open (LOG, ">>$args{controlDir}/pipeline.log") || die "Can't open log file '$args{controlDir}/pipeline.log' for writing\n";
&log("Running cmd: eupathUserDbMigration " . join(" ", @argv));
my $cursor = 0;
while ($cursor < scalar(@expandedSteps)) {

  my $step = $expandedSteps[$cursor];
  my $stepName = $step->{name};
  if (-e "$stepName.failed") {
    &log("Step '$stepName' failed.  Can't proceed");
    exit 1;
  }
  if (-e "$stepName.done") {
    &log("Step '$stepName' done");
    if ($args{stopAfterStep} eq $stepName) {
      &log("StopAfter='$stepName'.  Exiting");
      exit 0;
    }
    $cursor++;
    next;
  }
  if (-e "$stepName.running") {
    next;
  }
  if ($step->{skip}) {
    &log("Step '$stepName' skipped");
    $cursor++;
    next;
  }
  &log("Step '$stepName' running: '$step->{cmd}'");
  my $cmd = "echo '$step->{cmd}' | eupathUserDbMigrationStepWrapper $stepName &";
print "\n";
  system($cmd) && die "Failed running '$cmd'";
  sleep(1);
}
&log("Pipeline run complete");

sub log {
  my ($msg) = @_;
  my $t = localtime;
  print LOG "$t\t$msg\n\n";
}

sub validatingAndStopAfter {
  my ($step) = @_;
  if ($args{validateSteps}) {
    print "\n";
    print STDERR "$step->{name}:\t$step->{cmd}\n";
    if ($args{stopAfterStep} eq $step->{name}) {
      print STDERR "StopAfter='$step->{name}'.  Exiting\n";
      return 1;
    }
  }
  return 0;
}

sub usage {

  my $stepsSpecNames = join(", ", keys(%stepsSpec));

die "

eupathUserDbMigration --stepsSpecName spec_name {--controlDir my_control_dir | --listSteps | --validateSteps } [--stopAfterStep step_name] [--skipSteps comma_delim_list_of_steps] [--usingSandbox]

Where:
  stepsSpecName: the name of a list of steps to run.  Options are: $stepsSpecNames
  controlDir: the dir in which this program will write all its log files
  listSteps: list the steps in the provided stepsSpecName.  (Does not expand steps based on PROJECT_MACRO)
  validateSteps: don't run any commands.  Just validate the steps in the provided stepsSpecName (expanding PROJECT_MACRO), confirming that all required step-specific args are provided.
  stopAfterStep: the name of the step to stop after (Default: none)
  skipSteps: a comma delimited list of steps to skip (Default: none)
  usingSandbox: skip the steps marked as useful only in a replication context

Additional step-specific arguments are: --" . join(" --", @stepSpecificArgs) . "

To create or edit a pipeline, you have to edit the source code \$PROJECT_HOME/EuPathSiteCommon/Model/bin/eupathUserDbMigration.  See instructions in line.

To run multiple, parallel, pipelines (one per project), see the eupathUserDbMigrationMulti command

Mapping files
The mapping files describe  mappings for question names and parameter values.
MORE DETAILS HERE...

";

}
